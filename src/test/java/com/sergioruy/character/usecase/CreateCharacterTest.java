package com.sergioruy.character.usecase;

import com.sergioruy.character.CharacterBaseTest;
import com.sergioruy.character.dto.CharacterDTO;
import com.sergioruy.character.entity.CharacterEntity;
import com.sergioruy.character.usecase.adapter.CreateCharacterRepository;
import io.quarkus.test.InjectMock;
import io.quarkus.test.junit.QuarkusTest;
import jakarta.inject.Inject;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.*;

@QuarkusTest
class CreateCharacterTest extends CharacterBaseTest {

    @Inject
    CreateCharacter createCharacter;

    @InjectMock
    CreateCharacterRepository createCharacterRepository;

    @InjectMock
    GetCharacter getCharacter;

    CharacterDTO characterDTO;

    @BeforeEach
    void setup() {
        characterDTO = new CharacterDTO(
                "Goku",
                "Lawful Good",
                "Z Fighters");
    }

    @Test
    @DisplayName("Create Character without good validation")
    void createCharacterShouldCallPersistMethod() {
        // Mock the dependencies for simulate the behavior
        when(getCharacter.exists(anyString())).thenReturn(false);
        when(getCharacter.getCharacter(anyString())).thenReturn(characterDTO);

        // Execute the method that be tested
        createCharacter.createCharacter(characterDTO);

        // O test will pass if the persistence layer be called once.
        // But we don't know which object is passed and if the data are corrected!
        verify(createCharacterRepository, times(1)).persistCharacter(any(CharacterEntity.class));
    }

    @Test
    @DisplayName("Good practice, but still not guarantee what was passed to the persistence layer")
    void createCharacterShouldWorkAndCallPersistMethod() {

        when(getCharacter.exists(anyString())).thenReturn(false);
        when(getCharacter.getCharacter(anyString())).thenReturn(characterDTO);

        CharacterDTO dto = createCharacter.createCharacter(characterDTO);

        assertEquals(dto.name(), characterDTO.name());
        assertEquals(dto.alignment(), characterDTO.alignment());
        assertEquals(dto.superGroup(), characterDTO.superGroup());
    }

    @Test
    @DisplayName("Good practice, and using argument capture for check the data consistency")
    void createCharacterShouldWorkAndCallPersistMethodWithCorrectData() {

        when(getCharacter.exists(anyString())).thenReturn(false);
        when(getCharacter.getCharacter(anyString())).thenReturn(characterDTO);

        CharacterDTO dto = createCharacter.createCharacter(characterDTO);

        assertEquals(dto.name(), characterDTO.name());
        assertEquals(dto.alignment(), characterDTO.alignment());
        assertEquals(dto.superGroup(), characterDTO.superGroup());


        // Using argument capture, for capture the passed object for the method persistCharacter of the repository.
        ArgumentCaptor<CharacterEntity> characterCaptor = ArgumentCaptor.forClass(CharacterEntity.class);
        verify(createCharacterRepository, times(1)).persistCharacter(characterCaptor.capture());


        // Get the captured Entity and make the assertions
        CharacterEntity capturedCharacter = characterCaptor.getValue();

        // Assertions with Argument Capture
        assertNotNull(capturedCharacter.getId(), "The ID should be generated by the use case.");
        assertEquals("Goku", capturedCharacter.getName(), "The name should be same of the DTO.");
        assertEquals("Lawful Good", capturedCharacter.getAlignment(), "The alignment should be same of the DTO.");
        assertEquals("Z Fighters", capturedCharacter.getSuperGroup(), "The supergroup should be same of the DTO.");
    }
}
